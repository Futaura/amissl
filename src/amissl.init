#include <exec/types.h>
#include <exec/nodes.h>
#include <exec/memory.h>
#include <exec/resident.h>
#include <exec/libraries.h>
#include <exec/execbase.h>
#include <libraries/dos.h>
#include <proto/exec.h>
#include <string.h>
#include <stdlib.h>

#include <proto/exec.h>
#include <proto/utility.h>

#include <clib/dos_protos.h>
#include <pragmas/dos_pragmas.h>

#include <proto/locale.h>
#include <exec/memory.h>
#include <utility/tagitem.h>
#include <amissl/tags.h>
#include <exec/semaphores.h>

#include <openssl/crypto.h>
#include <openssl/lhash.h>
#include <libraries/amisslmaster.h>
#include <libraries/amissl.h>
#include "/scmt/scmt.h"
#include <proto/rsa.h>
#include <proto/dh.h>
#include <proto/dsa.h>
#include <proto/des.h>
#include <proto/mdc2.h>
#include <clib/amissl_protos.h>
#include "amisslinit.h"

struct ExecBase *SysBase;
struct Library *UtilityBase;
struct IntuitionBase *IntuitionBase;
struct DosLibrary *DOSBase;

struct Library *BlowFishBase;
struct Library *CASTBase;
struct Library *DESBase;
struct Library *IDEABase;
struct Library *MD2Base;
struct Library *MD4Base;
struct Library *MD5Base;
struct Library *MDC2Base;
struct Library *RC2Base;
struct Library *RC4Base;
struct Library *RC5Base;
struct Library *RIPEMDBase;
struct Library *SHABase;
struct Library *RSABase;
struct Library *DHBase;
struct Library *DSABase;
void *__pool;

#define XMKSTR(x)	#x
#define MKSTR(x)	XMKSTR(x)

static const char *version = "$VER: " MKSTR(LIBNAME) " " MKSTR(LIBVER) " " __AMIGADATE__ " part of AmiSSL package, " MKSTR(CPUPREFIX) MKSTR(CPUVER) " version";

static struct SignalSemaphore lock_cs[CRYPTO_NUM_LOCKS];
struct SignalSemaphore __mem_cs;
__far struct SignalSemaphore openssl_cs = {NULL};
__far LONG SemaphoreInitialized = 0;
__far struct HashTable *thread_hash = NULL;
ULONG base;

clock_t clock(void)
{
	struct DateStamp ds;
	ULONG tics;
	DateStamp(&ds);
	tics = ds.ds_Minute + ds.ds_Days * 60*24;
	return (tics-base)*CLOCKS_PER_SEC;
}

AMISSL_STATE *CreateAmiSSLState(void)
{
	AMISSL_STATE *ret;
	long pid = (long)FindTask(NULL);

	ObtainSemaphore(&openssl_cs);
	ret = (AMISSL_STATE *)malloc(sizeof(AMISSL_STATE));
	if (ret != NULL) {
//		kprintf("Allocating new state for %08lx\n",pid);
		ret->pid = pid;
		ret->errno = 0;
		ret->getenv_var = 0;
		ret->stack = 0;
		if(!h_insert(thread_hash, pid, ret))
		{
			free(ret);
			ret = NULL;
		}
	}
	ReleaseSemaphore(&openssl_cs);
	return ret;
}

#pragma syscall SB_ObtainSemaphore 234 801
#pragma syscall SB_ReleaseSemaphore 23a 801
#pragma syscall SB_FindTask 126 901

void SB_ObtainSemaphore(struct SignalSemaphore *);
void SB_ReleaseSemaphore(struct SignalSemaphore *);
struct Task *SB_FindTask(STRPTR);

AMISSL_STATE *GetAmiSSLState(void)
{
	AMISSL_STATE *ret;

	SB_ObtainSemaphore(&openssl_cs);
	ret = (AMISSL_STATE *)h_find(thread_hash, (long)SB_FindTask(NULL));
//	kprintf("Looked up state %08lx for %08lx\n",ret,pid);
	SB_ReleaseSemaphore(&openssl_cs);
	return ret;
}

void SetAmiSSLerrno(int errno)
{
	AMISSL_STATE *p = GetAmiSSLState();
	p->errno = errno;
}

int GetAmiSSLerrno(void)
{
	AMISSL_STATE *p = GetAmiSSLState();
	return p->errno;
}

static void
amigaos_locking_callback(int mode,int type,char *file,int line)
{
	if (mode & CRYPTO_LOCK)
		ObtainSemaphore(&(lock_cs[type]));
	else
		ReleaseSemaphore(&(lock_cs[type]));
}

__stdargs void cleanupState(long Key,AMISSL_STATE *a)
{
	h_delete(thread_hash,a->pid);
	free(a);
}

void __saveds __asm __UserLibCleanup(register __a6 struct MyLibrary *libbase)
{
	if(thread_hash)
	{
		ObtainSemaphore(&openssl_cs);
		h_doall(thread_hash,cleanupState); /* Clean up any left overs from tasks not calling cleanup */
		ReleaseSemaphore(&openssl_cs);
	}

	if(IntuitionBase)
		CloseLibrary((struct Library *)IntuitionBase);
	if(UtilityBase)
		CloseLibrary((struct Library *)UtilityBase);
	if(__pool)
		DeletePool(__pool);
}

void __saveds __asm __UserLibExpunge(register __a6 struct MyLibrary *libbase)
{
	ObtainSemaphore(&openssl_cs);
	if(thread_hash)
	{
		h_doall(thread_hash,cleanupState); /* Clean up any left overs from tasks not calling cleanup */
		h_free(thread_hash);
		thread_hash = NULL;
	}
	ReleaseSemaphore(&openssl_cs);
}

LONG GMTOffset;

__stdargs void *h_allocfunc(long size)
{
	return AllocVec(size,MEMF_ANY);
}

__stdargs void h_freefunc(void *mem)
{
	FreeVec(mem);
}

int __saveds __asm __UserLibInit(register __a6 struct MyLibrary *libbase)
{
	struct Library *LocaleBase;
	struct Locale *Loc;

	int i;

	SysBase = *(struct ExecBase **)4;

	if(!thread_hash)
	{
		Forbid();
		if(!SemaphoreInitialized)
		{
			InitSemaphore(&openssl_cs);
			SemaphoreInitialized = TRUE;
		}
		Permit();
		ObtainSemaphore(&openssl_cs);
		if(!thread_hash)
		{
			thread_hash = h_new(7, h_allocfunc,h_freefunc);
		}
		ReleaseSemaphore(&openssl_cs);
	}

	if(__pool = CreatePool(MEMF_ANY, 8192, 4096))
	{
		for (i=0; i<CRYPTO_NUM_LOCKS; i++)
			InitSemaphore(&lock_cs[i]);
		InitSemaphore(&__mem_cs);

		CRYPTO_set_locking_callback((void (*)())amigaos_locking_callback);
		if(DOSBase = (struct DosLibrary *)OpenLibrary("dos.library",36L))
		{
			struct DateStamp ds;
			DateStamp(&ds);
			base = ds.ds_Minute + ds.ds_Days * 60*24;

			if(UtilityBase = OpenLibrary("utility.library", 36))
			{
				if ((IntuitionBase = (struct IntuitionBase*)OpenLibrary("intuition.library", 36)))
				{
					if (LocaleBase = OpenLibrary("locale.library", 38))
					{
						if (Loc = OpenLocale(NULL))
						{
							GMTOffset = Loc->loc_GMTOffset;
							CloseLocale(Loc);
						}
						CloseLibrary(LocaleBase);
					}
					goto ok;
				}
			}
		}
	}
	goto error;
ok:
	return(0);
error:
	__UserLibCleanup(libbase);
	return(1);
}

long SSLVersionApp = 0;

long __saveds __asm InitAmiSSLA_AmiSSL(register __a0 struct TagItem *tagList,register __a6 struct Library *AmiSSLBase)
{
	AMISSL_STATE *state;

	if(state = CreateAmiSSLState())
	{
		state->a4 = (APTR)getreg(REG_A4);
		state->stack = (APTR)GetTagData(AmiSSL_TCPStack, NULL, tagList);
		SSLVersionApp = GetTagData(AmiSSL_SSLVersionApp, 0, tagList);

		if(DHBase)
		{
			InitDH(AmiSSLBase,SHABase);
		}

		if(DSABase)
		{
			InitDSA(AmiSSLBase,SHABase);
		}

		if(RSABase)
		{
			if(InitRSA(AmiSSLBase,SHABase,MD5Base))
			{
				return 1;
			}
		}

		if(DESBase)
		{
			InitDES(AmiSSLBase);
		}

		if(MDC2Base)
		{
			InitMDC2(DESBase);
		}
	
		return(0);
	}
	return 1;
}

long __saveds __asm CleanupAmiSSLA_AmiSSL(register __a0 struct TagItem *tagList)
{
	AMISSL_STATE *state;

	if(RSABase)
	{
		CleanupRSA();
	}

	if(state = GetAmiSSLState())
	{
		ObtainSemaphore(&openssl_cs);
		h_delete(thread_hash, state->pid);
		ReleaseSemaphore(&openssl_cs);
		free(state);
	}
	return(0);
}

__stdargs void _CXFERR(int code)
{ /* do nothing since no one will ever look at the fp error code */
}

__stdargs void syslog(int priority, const char * message, ...)
{
}

__saveds __asm void InternalInitAmiSSL_AmiSSL(register __a0 struct AmiSSLInitStruct *amisslinit)
{
	BlowFishBase = amisslinit->BlowFishBase;
	CASTBase = amisslinit->CASTBase;
	DESBase = amisslinit->DESBase;
	IDEABase = amisslinit->IDEABase;
	MD2Base = amisslinit->MD2Base;
	MD4Base = amisslinit->MD4Base;
	MD5Base = amisslinit->MD5Base;
	MDC2Base = amisslinit->MDC2Base;
	RC2Base = amisslinit->RC2Base;
	RC4Base = amisslinit->RC4Base;
	RC5Base = amisslinit->RC5Base;
	RIPEMDBase = amisslinit->RIPEMDBase;
	SHABase = amisslinit->SHABase;
	RSABase = amisslinit->RSABase;
	DHBase = amisslinit->DHBase;
	DSABase = amisslinit->DSABase;
}
